use convert_case::{Case, Casing};
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let svg_dir = format!("{}/resources/ratel", manifest_dir);
    let output_file = format!("{}/src/icons/ratel/mod.rs", manifest_dir);

    // Tell cargo to rerun when SVG files change
    println!("cargo:rerun-if-changed={}", &svg_dir);

    // Scan for SVG files
    let svg_files = scan_svg_files(&svg_dir);

    // Generate components
    let components = svg_files
        .iter()
        .filter_map(|path| generate_component(path))
        .collect::<Vec<_>>();

    if components.is_empty() {
        eprintln!("Warning: No SVG files found in {}", svg_dir);
    }

    // Write output file
    let output = format!(
        "// Auto-generated by build.rs - DO NOT EDIT\nuse dioxus::prelude::*;\n\n{}",
        components.join("\n\n")
    );

    fs::write(output_file, output).expect("Failed to write mod.rs");

    println!(
        "cargo:warning=Generated {} icon components",
        components.len()
    );
}

fn scan_svg_files(dir: &str) -> Vec<PathBuf> {
    let mut files = Vec::new();

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().map_or(false, |ext| ext == "svg") {
                files.push(path);
            }
        }
    }

    files.sort();
    files
}

fn generate_component(svg_path: &Path) -> Option<String> {
    let svg_content = fs::read_to_string(svg_path).ok()?;
    let file_stem = svg_path.file_stem()?.to_str()?;

    // Convert filename to PascalCase
    // logo.svg -> Logo, logo_letter.svg -> LogoLetter
    let component_name = file_stem
        .replace('-', "_")
        .from_case(Case::Snake)
        .to_case(Case::Pascal);

    // Parse SVG
    let doc = roxmltree::Document::parse(&svg_content).ok()?;
    let svg_root = doc.root_element();

    // Extract viewBox and other attributes
    let view_box = svg_root.attribute("viewBox").unwrap_or("0 0 24 24");
    let xmlns = svg_root
        .attribute("xmlns")
        .unwrap_or("http://www.w3.org/2000/svg");

    // Generate children RSX
    let children_rsx = generate_children_rsx(&svg_root, 12);

    // Generate component function
    let component = format!(
        r#"#[component]
pub fn {name}(
    #[props(default = "32")] width: &'static str,
    #[props(default = "32")] height: &'static str,
    #[props(default = "currentColor")] fill: &'static str,
    #[props(default = None)] class: Option<&'static str>,
) -> Element {{
    rsx! {{
        svg {{
            width: "{{width}}",
            height: "{{height}}",
            view_box: "{view_box}",
            fill: "{{fill}}",
            xmlns: "{xmlns}",
            class: if let Some(c) = class {{ c }} else {{ "" }},
{children}
        }}
    }}
}}"#,
        name = component_name,
        view_box = view_box,
        xmlns = xmlns,
        children = children_rsx
    );

    Some(component)
}

fn generate_children_rsx(element: &roxmltree::Node, indent: usize) -> String {
    let mut output = String::new();
    let child_indent_str = " ".repeat(indent + 4);

    for child in element.children() {
        if !child.is_element() {
            continue;
        }

        let tag_name = child.tag_name().name();

        // Generate opening tag with attributes
        output.push_str(&format!("{}{} {{\n", child_indent_str, tag_name));

        // Generate attributes
        for attr in child.attributes() {
            let attr_name = attr.name();
            let attr_value = attr.value();

            // Convert kebab-case to snake_case
            let rust_attr_name = attr_name.replace("-", "_");

            // Escape quotes in attribute values
            let escaped_value = attr_value.replace('"', "\\\"");
            output.push_str(&format!(
                "{}{}: \"{}\",\n",
                child_indent_str.clone() + "    ",
                rust_attr_name,
                escaped_value
            ));
        }

        // Recursively generate children
        let children_str = generate_children_rsx(&child, indent + 8);
        if !children_str.trim().is_empty() {
            output.push_str(&children_str);
        }

        output.push_str(&format!("{}}}\n", child_indent_str));
    }

    output
}
