use convert_case::{Case, Casing};
use std::fs;
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let svg_dir = manifest_dir.join("resources");
    let output_dir = manifest_dir.join("src/icons");

    if !output_dir.exists() {
        fs::create_dir_all(&output_dir).ok();
    }

    println!("cargo:rerun-if-changed={}", svg_dir.display());

    let mut icon_groups: std::collections::BTreeMap<String, Vec<(PathBuf, String)>> =
        std::collections::BTreeMap::new();
    if let Ok(entries) = fs::read_dir(&svg_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                let dir_name = path
                    .file_name()
                    .and_then(|n| n.to_str())
                    .map(|s| s.to_string());

                if let Some(dir_name) = dir_name {
                    let svg_files = scan_svg_files(&path);
                    if !svg_files.is_empty() {
                        let module_name = dir_name.replace('-', "_");
                        let files_with_names: Vec<(PathBuf, String)> = svg_files
                            .iter()
                            .filter_map(|p| {
                                extract_component_name(p).map(|name| (p.clone(), name))
                            })
                            .collect();
                        icon_groups.insert(module_name, files_with_names);
                    }
                }
            }
        }
    }

    if icon_groups.is_empty() {
        println!("cargo:warning=No SVG files found in {}", svg_dir.display());
        return;
    }

    let mut total_count = 0;

    for (group_name, files_with_names) in icon_groups.iter() {
        let group_output_dir = output_dir.join(group_name);
        if !group_output_dir.exists() {
            fs::create_dir_all(&group_output_dir).ok();
        }

        let output_file = group_output_dir.join("mod.rs");
        let file = fs::File::create(&output_file).expect("Failed to create output file");
        let mut writer = BufWriter::new(file);

        writeln!(writer, "// Auto-generated by build.rs - DO NOT EDIT").unwrap();
        writeln!(writer, "#![allow(non_snake_case, unused_braces)]").unwrap();
        writeln!(writer, "use dioxus::prelude::*;").unwrap();
        writeln!(writer, "").unwrap();

        let mut count = 0;
        for (path, _name) in files_with_names {
            if let Some(component) = generate_component(path) {
                writeln!(writer, "{}\n", component).unwrap();
                count += 1;
            }
        }

        total_count += count;
    }

    // Generate main mod.rs (only module declarations)
    let main_mod_file = output_dir.join("mod.rs");
    let file = fs::File::create(&main_mod_file).expect("Failed to create main mod.rs");
    let mut writer = BufWriter::new(file);

    writeln!(writer, "// Auto-generated by build.rs - DO NOT EDIT").unwrap();
    writeln!(writer, "").unwrap();

    // Re-export all category modules
    for group_name in icon_groups.keys() {
        writeln!(writer, "pub mod {};", group_name).unwrap();
    }

    println!(
        "cargo:warning=Generated {} icon components in {} groups",
        total_count,
        icon_groups.len()
    );

    // Run dx fmt on generated files
    let _ = std::process::Command::new("dx")
        .arg("fmt")
        .current_dir(&manifest_dir)
        .output();
}

fn extract_component_name(svg_path: &Path) -> Option<String> {
    let file_stem = svg_path.file_stem()?.to_str()?;

    let normalized_name = if file_stem.chars().next()?.is_numeric() {
        let num_end = file_stem
            .find(|c: char| !c.is_numeric())
            .unwrap_or(file_stem.len());
        let remainder = &file_stem[num_end..];
        if remainder.is_empty() || remainder.starts_with('-') || remainder.starts_with('_') {
            format!(
                "Icon{}",
                if remainder.is_empty() {
                    String::new()
                } else {
                    remainder[1..].to_string()
                }
            )
        } else {
            format!("Icon{}", remainder)
        }
    } else {
        file_stem.to_string()
    };

    let component_name = normalized_name
        .replace(['-', ' ', '.'], "_")
        .from_case(Case::Snake)
        .to_case(Case::Pascal);

    Some(component_name)
}

fn scan_svg_files(dir: &Path) -> Vec<PathBuf> {
    let mut files = Vec::new();
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                files.extend(scan_svg_files(&path));
            } else if path.extension().map_or(false, |ext| ext == "svg") {
                files.push(path);
            }
        }
    }
    files.sort();
    files
}

fn generate_component(svg_path: &Path) -> Option<String> {
    let svg_content = fs::read_to_string(svg_path).ok()?;
    let file_stem = svg_path.file_stem()?.to_str()?;

    let normalized_name = if file_stem.chars().next()?.is_numeric() {
        let num_end = file_stem
            .find(|c: char| !c.is_numeric())
            .unwrap_or(file_stem.len());
        let remainder = &file_stem[num_end..];
        if remainder.is_empty() || remainder.starts_with('-') || remainder.starts_with('_') {
            format!(
                "Icon{}",
                if remainder.is_empty() {
                    String::new()
                } else {
                    remainder[1..].to_string()
                }
            )
        } else {
            format!("Icon{}", remainder)
        }
    } else {
        file_stem.to_string()
    };

    let component_name = normalized_name
        .replace(['-', ' ', '.'], "_")
        .from_case(Case::Snake)
        .to_case(Case::Pascal);

    let doc = roxmltree::Document::parse(&svg_content).ok()?;
    let svg_root = doc.root_element();
    let view_box = svg_root.attribute("viewBox").unwrap_or("0 0 24 24");

    let children_rsx = generate_children_rsx(&svg_root, 8);

    Some(format!(
        r#"#[component]
pub fn {name}(
    #[props(default = "24")] width: &'static str,
    #[props(default = "24")] height: &'static str,
    class: Option<&'static str>,
) -> Element {{
    rsx! {{
        svg {{
            width: width,
            height: height,
            view_box: "{view_box}",
            class: class.unwrap_or_default(),
            xmlns: "http://www.w3.org/2000/svg",
{children}
        }}
    }}
}}"#,
        name = component_name,
        view_box = view_box,
        children = children_rsx
    ))
}

fn generate_children_rsx(element: &roxmltree::Node, indent: usize) -> String {
    use std::fmt::Write;
    let mut output = String::new();
    let indent_str = " ".repeat(indent);

    for child in element.children().filter(|n| n.is_element()) {
        let tag_name = child.tag_name().name();

        writeln!(output, "{}{} {{", indent_str, tag_name).unwrap();

        for attr in child.attributes() {
            let attr_name = attr.name();
            let value = attr.value();

            let kebab_attr = attr_name.from_case(Case::Camel).to_case(Case::Kebab);

            if should_skip_attribute(&kebab_attr, value) {
                continue;
            }

            let escaped_value = value.replace('"', "\\\"");
            writeln!(
                output,
                "{}    \"{}\": \"{}\",",
                indent_str, kebab_attr, escaped_value
            )
            .unwrap();
        }

        let children_content = generate_children_rsx(&child, indent + 4);
        if !children_content.is_empty() {
            output.push_str(&children_content);
        }

        writeln!(output, "{}}}", indent_str).unwrap();
    }
    output
}

fn should_skip_attribute(name: &str, value: &str) -> bool {
    match name {
        "xmlns" | "id" | "class" if value.is_empty() => true,
        _ => false,
    }
}
