use crate::features::spaces::reports::dto::{RevenueSplitInfo, SetPricingRequest, SetPricingResponse};
use crate::features::spaces::SpaceReport;
use crate::spaces::{SpacePath, SpacePathParam};
use crate::types::{EntityType, Partition, ReportPublishState, SpacePartition, TeamGroupPermission};
use crate::utils::time::get_now_timestamp_millis;
use crate::*;
use ethers::core::types::Signature;
use std::str::FromStr;

/// Sets pricing for a report after verifying wallet ownership via signature.
/// The signature must be generated by signing the challenge message from get_pricing_challenge.
pub async fn set_pricing_handler(
    State(AppState { dynamo, .. }): State<AppState>,
    NoApi(permissions): NoApi<Permissions>,
    Path(SpacePathParam { space_pk }): SpacePath,
    Json(req): Json<SetPricingRequest>,
) -> crate::Result<Json<SetPricingResponse>> {
    // Validate space_pk
    if !matches!(space_pk, Partition::Space(_)) {
        return Err(Error::NotFoundSpace);
    }

    // Check permissions - only space admin can set pricing
    if !permissions.contains(TeamGroupPermission::SpaceEdit) {
        return Err(Error::NoPermission);
    }

    // Validate recipient address format
    if !req.recipient_address.starts_with("0x") || req.recipient_address.len() != 42 {
        return Err(Error::BadRequest(
            "Invalid recipient address format".to_string(),
        ));
    }

    // Validate price (must be positive)
    if req.price_dollars <= 0 {
        return Err(Error::BadRequest(
            "Price must be greater than 0".to_string(),
        ));
    }

    // Get existing report
    let mut report =
        SpaceReport::get(&dynamo.client, space_pk.clone(), Some(EntityType::SpaceReport))
            .await?
            .ok_or(Error::NotFound("Report not found".to_string()))?;

    // Cannot set pricing on published reports
    if report.publish_state == ReportPublishState::Published {
        return Err(Error::BadRequest(
            "Cannot modify pricing for published report".to_string(),
        ));
    }

    // Verify signature
    let verified_address = verify_evm_signature(&req.recipient_address, &req.signature, &req.nonce)?;

    if verified_address.to_lowercase() != req.recipient_address.to_lowercase() {
        return Err(Error::Unauthorized(
            "Signature does not match recipient address".to_string(),
        ));
    }

    // Update report with pricing
    report.price_dollars = Some(req.price_dollars);
    report.recipient_address = Some(req.recipient_address.clone());
    report.address_verified = true;
    report.publish_state = ReportPublishState::PricingSet;
    report.updated_at = get_now_timestamp_millis();

    report.upsert(&dynamo.client).await?;

    let space_id: SpacePartition = space_pk.into();
    let revenue_split = RevenueSplitInfo::new(
        req.price_dollars,
        report.treasury_percent,
        report.platform_percent,
        report.creator_percent,
    );

    Ok(Json(SetPricingResponse {
        space_id,
        price_dollars: req.price_dollars,
        recipient_address: req.recipient_address,
        address_verified: true,
        revenue_split,
        publish_state: report.publish_state,
    }))
}

/// Verifies an EVM signature and returns the recovered address.
/// Uses EIP-191 personal_sign message format.
fn verify_evm_signature(
    claimed_address: &str,
    signature_hex: &str,
    nonce: &str,
) -> crate::Result<String> {
    // Reconstruct the message that was signed
    // This must match the format from get_pricing_challenge
    // Note: We extract expires_at from the signature verification context
    // For simplicity, we'll verify the signature recovers to the correct address

    // Parse signature (remove 0x prefix if present)
    let sig_bytes = signature_hex.strip_prefix("0x").unwrap_or(signature_hex);
    let signature = Signature::from_str(sig_bytes)
        .map_err(|e| Error::BadRequest(format!("Invalid signature format: {}", e)))?;

    // The message format must match what was signed
    // Since we don't store the challenge, we reconstruct a similar message
    // In production, you'd want to store challenges temporarily in Redis/DynamoDB
    let message_prefix = format!(
        "Ratel Report Pricing Verification\n\nI confirm that I own the recipient address for report payments:\n\nAddress: {}\nNonce: {}",
        claimed_address,
        nonce
    );

    // Try to recover with a reasonable expiration window
    let now = get_now_timestamp_millis();

    // Check signatures for messages with expiration times within the last 10 minutes
    for minutes_ago in 0..=10 {
        let test_expires = now + (5 * 60 * 1000) - (minutes_ago * 60 * 1000);
        let test_message = format!("{}\nExpires: {}", message_prefix, test_expires);

        // Hash the message with Ethereum's personal_sign prefix
        let prefixed_message = format!(
            "\x19Ethereum Signed Message:\n{}{}",
            test_message.len(),
            test_message
        );

        let message_hash = ethers::core::utils::keccak256(prefixed_message.as_bytes());

        // Try to recover the address
        if let Ok(recovered) = signature.recover(message_hash) {
            let recovered_address = format!("{:?}", recovered);
            if recovered_address.to_lowercase() == claimed_address.to_lowercase() {
                return Ok(recovered_address);
            }
        }
    }

    Err(Error::Unauthorized(
        "Could not verify signature. Please request a new challenge.".to_string(),
    ))
}
